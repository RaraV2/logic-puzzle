<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Logic Circuit Puzzle Game</title>
<style>
    body { font-family: Arial, sans-serif; background:#111; color:#fff; margin:0; padding:0;}
    .container { padding:20px; max-width:1200px; margin:auto;}
    h3, h4 { margin:5px 0;}
    .circuit-container { position: relative; margin:20px 0; }
    .circuit-grid { display: grid; grid-gap: 20px; position: relative; }
    .circuit-element { text-align:center; padding:5px; border-radius:5px; }
    .input-element { background:#222; border:1px solid #0ff; }
    .gate-element { background:#333; border:1px solid #0f0; }
    .output-element { background:#222; border:1px solid #f0f; }
    .input-toggle { width:30px; height:30px; margin:auto; background:#444; border-radius:50%; cursor:pointer; }
    .input-toggle.active { background:#ff6b6b; }
    .element-label { font-size:14px; margin-top:5px; }
    .element-value { font-size:12px; margin-top:2px; }
    .success { background:#0a0; color:#fff; padding:10px; margin:10px 0; border-radius:5px; }
    .error { background:#a00; color:#fff; padding:10px; margin:10px 0; border-radius:5px; }
    .btn { margin:5px; padding:5px 10px; cursor:pointer; border:none; border-radius:5px; background:#0ff; color:#000; font-weight:bold; }
    .btn:hover { background:#0cc; }
    .truth-table { background:#222; padding:10px; border-radius:5px; margin:10px 0; overflow-x:auto; }
    table { border-collapse: collapse; width:100%; }
    th, td { border:1px solid #fff; padding:5px; text-align:center; }
    .target { background:#0f0; color:#000; }
    @keyframes pulse { 0% {stroke-width:3;} 100% {stroke-width:6;} }
</style>
</head>
<body>
<div class="container">
    <div id="levelInfo">
        <h3 id="puzzle-title">Level 1: Basic AND Gate</h3>
        <p id="puzzle-description">Connect inputs to create the target output. Start with a simple AND gate.</p>
    </div>
    <div class="target-section">
        <div class="target">
            <h4>üéØ Target Pattern</h4>
            <div id="target-outputs"><strong>Q: 1 (TRUE)</strong></div>
        </div>
    </div>
    <div class="circuit-container">
        <div class="circuit" id="circuit"></div>
    </div>
    <div class="controls">
        <button class="btn" onclick="checkSolution()">‚úì Check Solution</button>
        <button class="btn" onclick="nextLevel()" id="nextBtn" disabled>‚Üí Next Level</button>
        <button class="btn" onclick="resetPuzzle()">‚Üª Reset</button>
        <button class="btn" onclick="showHint()">üí° Hint</button>
        <button class="btn" onclick="showTruthTable()">üìä Truth Table</button>
        <button class="btn" onclick="showCircuitInfo()">‚ÑπÔ∏è Info</button>
    </div>
    <div class="hint" id="hint"></div>
    <div class="truth-table" id="truthTable">
        <h4>Truth Table for Current Circuit</h4>
        <div id="truthTableContent"></div>
    </div>
    <div id="message" style="display: none;"></div>
</div>

<script>
let currentLevel = 1;
let score = 0;
let attempts = 0;
let streak = 0;
let bestStreak = 0;
let hintsUsed = 0;
let solved = false;
let startTime = Date.now();
let inputs = {};
let timerInterval;

const levels = [
    {
        title: "Level 1: Basic AND Gate",
        description: "Learn the fundamentals: output is TRUE only when both inputs are TRUE.",
        difficulty: "easy",
        inputs: ["A", "B"],
        outputs: ["Q"],
        gates: [{ type: "AND", inputs: ["A", "B"], output: "Q" }],
        targets: { "Q": [1] },
        hint: "AND gate: Both inputs must be 1 to get output 1. Try A=1, B=1."
    },
    {
        title: "Level 2: Basic OR Gate",
        description: "OR gate outputs TRUE when at least one input is TRUE.",
        difficulty: "easy",
        inputs: ["A", "B"],
        outputs: ["Q"],
        gates: [{ type: "OR", inputs: ["A", "B"], output: "Q" }],
        targets: { "Q": [0] },
        hint: "OR gate outputs 0 only when both inputs are 0. Try A=0, B=0."
    },
    {
        title: "Level 3: NOT Gate Chain",
        description: "NOT gates invert the input. Chain them for interesting effects.",
        difficulty: "easy",
        inputs: ["A"],
        outputs: ["Q"],
        gates: [
            { type: "NOT", inputs: ["A"], output: "temp1" },
            { type: "NOT", inputs: ["temp1"], output: "Q" }
        ],
        targets: { "Q": [1] },
        hint: "Two NOT gates cancel each other out. If A=1, then NOT A = 0, then NOT(NOT A) = 1."
    }
];

// --- INIT ---
function initGame(){ loadLevel(); }

// --- LOAD LEVEL ---
function loadLevel() {
    const level = levels[currentLevel - 1];
    inputs = {}; level.inputs.forEach(i=>inputs[i]=false);
    document.getElementById('puzzle-title').textContent = level.title;
    document.getElementById('puzzle-description').textContent = level.description;
    generateCircuit(level);
    updateTargetDisplay(level);
    solved=false; document.getElementById('nextBtn').disabled=true;
    document.getElementById('message').style.display='none';
    document.getElementById('truthTable').style.display='none';
    document.getElementById('hint').style.display='none';
}

// --- CIRCUIT GENERATION ---
function generateCircuit(level){
    const circuit=document.getElementById('circuit'); circuit.innerHTML='';
    const circuitGrid=document.createElement('div'); circuitGrid.className='circuit-grid'; circuitGrid.id='circuitGrid';
    const layout=calculateGridLayout(level);

    // inputs
    level.inputs.forEach((inputName,index)=>{
        const inputDiv=document.createElement('div'); inputDiv.className='circuit-element input-element';
        inputDiv.style.gridColumn=layout.inputs[inputName].col; inputDiv.style.gridRow=layout.inputs[inputName].row;
        inputDiv.innerHTML=`<div class="input-toggle" id="input${inputName}" onclick="toggleInput('${inputName}')"></div>
        <div class="element-label">${inputName}</div>
        <div class="element-value" id="value${inputName}">0</div>`;
        circuitGrid.appendChild(inputDiv);
    });

    // gates
    level.gates.forEach((gate,gateIndex)=>{
        const gateDiv=document.createElement('div'); gateDiv.className='circuit-element gate-element';
        gateDiv.style.gridColumn=layout.gates[gate.output].col; gateDiv.style.gridRow=layout.gates[gate.output].row;
        const gateBox=document.createElement('div'); gateBox.className=gate.type==='NOT'?'gate not':'gate'; gateBox.textContent=gate.type;
        gateBox.id=`gate_${gate.output}`;
        gateDiv.appendChild(gateBox);
        gateDiv.innerHTML+=`<div class="element-label">${gate.output}</div><div class="element-value">${gate.inputs.join(',')}</div>`;
        circuitGrid.appendChild(gateDiv);
    });

    // outputs
    level.outputs.forEach(outputName=>{
        const outputDiv=document.createElement('div'); outputDiv.className='circuit-element output-element';
        outputDiv.style.gridColumn=layout.outputs[outputName].col; outputDiv.style.gridRow=layout.outputs[outputName].row;
        outputDiv.innerHTML=`<div class="output-display" id="output${outputName}">0</div>
        <div class="element-label">${outputName}</div>
        <div class="element-value" id="outputValue${outputName}">0 (FALSE)</div>`;
        circuitGrid.appendChild(outputDiv);
    });

    drawGridConnections(circuitGrid, layout, level);
    circuit.appendChild(circuitGrid);
    updateOutputs();
}

// --- GRID LAYOUT ---
function calculateGridLayout(level){
    const layout={inputs:{},gates:{},outputs:{},maxRow:1};
    level.inputs.forEach((i,index)=>layout.inputs[i]={col:2+index*2,row:1});
    let currentRow=3;
    groupGatesByDependency(level.gates).forEach(layer=>{
        layer.forEach((gate,index)=>layout.gates[gate.output]={col:2+index*2,row:currentRow,gate:gate});
        currentRow+=2;
    });
    level.outputs.forEach((o,index)=>layout.outputs[o]={col:2+index*2,row:currentRow});
    layout.maxRow=currentRow; return layout;
}
function groupGatesByDependency(gates){
    const layers=[]; const processed=new Set();
    while(processed.size<gates.length){
        const currentLayer=[];
        gates.forEach(g=>{
            if(!processed.has(g.output)){
                const canProcess=g.inputs.every(i=>!(gates.some(g2=>g2.output===i))||processed.has(i));
                if(canProcess) currentLayer.push(g);
            }
        });
        if(currentLayer.length===0) break;
        currentLayer.forEach(g=>processed.add(g.output));
        layers.push(currentLayer);
    }
    return layers;
}

// --- CONNECTIONS ---
function drawGridConnections(grid, layout, level){
    const cellWidth=80, cellHeight=60;
    const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.style.position='absolute'; svg.style.top='0'; svg.style.left='0'; svg.style.width='100%'; svg.style.height='100%'; svg.style.pointerEvents='none'; svg.style.zIndex='1';

    // gates
    level.gates.forEach(gate=>{
        gate.inputs.forEach(inputName=>{
            const startPos=layout.inputs[inputName]||layout.gates[inputName]; if(!startPos) return;
            const gatePos=layout.gates[gate.output];
            const startX=(startPos.col-1)*cellWidth+cellWidth/2;
            const startY=(startPos.row-1)*cellHeight+cellHeight/2;
            const gateX=(gatePos.col-1)*cellWidth+cellWidth/2;
            const gateY=(gatePos.row-1)*cellHeight+cellHeight/2;
            drawStraightConnection(svg,startX,startY,gateX,gateY,inputName,gate.output);
        });
    });

    // outputs
    level.outputs.forEach(outputName=>{
        const outputPos=layout.outputs[outputName];
        const gatePos=layout.gates[outputName]; if(!gatePos||!outputPos) return;
        const startX=(gatePos.col-1)*cellWidth+cellWidth/2;
        const startY=(gatePos.row-1)*cellHeight+cellHeight/2;
        const endX=(outputPos.col-1)*cellWidth+cellWidth/2;
        const endY=(outputPos.row-1)*cellHeight+cellHeight/2;
        drawStraightConnection(svg,startX,startY,endX,endY,outputName,outputName+'_out');
    });

    grid.appendChild(svg);
}
function drawStraightConnection(svg,startX,startY,endX,endY,fromSignal,toSignal){
    const group=document.createElementNS('http://www.w3.org/2000/svg','g');
    group.setAttribute('data-from',fromSignal); group.setAttribute('data-to',toSignal);

    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',startX); line.setAttribute('y1',startY);
    line.setAttribute('x2',endX); line.setAttribute('y2',endY);
    line.setAttribute('stroke','#00ffcc'); line.setAttribute('stroke-width','3');
    line.classList.add('connection-wire'); group.appendChild(line);

    const arrow=document.createElementNS('http://www.w3.org/2000/svg','polygon');
    arrow.setAttribute('points',`${endX-6},${endY-6} ${endX+6},${endY} ${endX-6},${endY+6}`);
    arrow.setAttribute('fill','#00ffcc'); arrow.classList.add('connection-arrow');
    group.appendChild(arrow); svg.appendChild(group);
}

// --- INPUT TOGGLE ---
function toggleInput(inputName){
    if(solved) return; inputs[inputName]=!inputs[inputName];
    const toggle=document.getElementById(`input${inputName}`); toggle.classList.toggle('active');
    document.getElementById(`value${inputName}`).textContent=inputs[inputName]?1:0;
    updateOutputs();
}

// --- EVALUATE ---
function evaluateGate(gate){
    const inputValues=gate.inputs.map(i=>inputs.hasOwnProperty(i)?inputs[i]:window.intermediateValues[i]||false);
    switch(gate.type){
        case 'AND': return inputValues.every(v=>v);
        case 'OR': return inputValues.some(v=>v);
        case 'NOT': return !inputValues[0];
        case 'XOR': return inputValues.reduce((a,b)=>a!==b,false);
        case 'XNOR': return !inputValues.reduce((a,b)=>a!==b,false);
        case 'NAND': return !inputValues.every(v=>v);
        case 'NOR': return !inputValues.some(v=>v);
        default: return false;
    }
}
function updateOutputs(){
    const level=levels[currentLevel-1]; window.intermediateValues={};
    level.gates.forEach(g=>{
        const res=evaluateGate(g); window.intermediateValues[g.output]=res;
        if(level.outputs.includes(g.output)){
            const outEl=document.getElementById(`output${g.output}`); const valEl=document.getElementById(`outputValue${g.output}`);
            if(outEl&&valEl){ outEl.textContent=res?1:0; outEl.classList.toggle('active',res); valEl.textContent=res?'1 (TRUE)':'0 (FALSE)'; }
        }
    }); updateWireColors();
}

// --- WIRE COLOR UPDATE ---
function updateWireColors(){
    document.querySelectorAll('.connection-wire').forEach(wire=>{
        const val=inputs[wire.getAttribute('data-from')]||window.intermediateValues[wire.getAttribute('data-from')]||false;
        if(val){ wire.setAttribute('stroke','#ff6b6b'); wire.style.animation='pulse 1s ease-in-out infinite alternate'; }
        else{ wire.setAttribute('stroke','#00ffcc'); wire.style.animation='none'; }
    });
}

// --- TARGET DISPLAY ---
function updateTargetDisplay(level){
    let text=''; for(const [out,vals] of Object.entries(level.targets)) text+=`${out}: ${vals[0]} (${vals[0]? 'TRUE':'FALSE'}) `;
    document.getElementById('target-outputs').innerHTML=`<strong>${text}</strong>`;
}

// --- SOLUTION CHECK ---
function checkSolution(){
    if(solved) return; const level=levels[currentLevel-1]; let correct=true; attempts++; document.getElementById('attempts')?.textContent=attempts;
    for(const [out,val] of Object.entries(level.targets)){ if((window.intermediateValues[out]?1:0)!==val[0]){ correct=false; break; } }
    const msg=document.getElementById('message'); if(correct){
        solved=true; streak++; if(streak>bestStreak){ bestStreak=streak; document.getElementById('streak')?.textContent=bestStreak; }
        const baseScore={'easy':100,'medium':200,'hard':400,'expert':800,'master':1600}[level.difficulty]; const penalty=Math.max(0,(attempts-1)*50)+hintsUsed*100;
        const levelScore=Math.max(50,baseScore-penalty); score+=levelScore; document.getElementById('score')?.textContent=score;
        document.getElementById('nextBtn').disabled=false; msg.className='success';
        msg.innerHTML=`üéâ Level ${currentLevel} Complete! +${levelScore} points`;
    } else { streak=0; msg.className='error'; msg.innerHTML='‚ùå Not correct. Try again!'; }
    msg.style.display='block';
}

// --- NEXT LEVEL ---
function nextLevel(){ if(currentLevel<levels.length){ currentLevel++; loadLevel(); } else{ alert('All levels complete!'); } }

// --- RESET ---
function resetPuzzle(){ loadLevel(); }

// --- HINT ---
function showHint(){ hintsUsed++; const level=levels[currentLevel-1]; const hintEl=document.getElementById('hint'); hintEl.innerHTML=`üí° Hint: ${level.hint}`; hintEl.style.display='block'; }

// --- TRUTH TABLE ---
function showTruthTable(){
    const level=levels[currentLevel-1]; const contentEl=document.getElementById('truthTableContent'); let html='<table><tr>';
    level.inputs.forEach(i=>html+=`<th>${i}</th>`); level.outputs.forEach(o=>html+=`<th>${o}</th>`); html+='</tr>';
    const numComb=Math.pow(2,level.inputs.length);
    for(let i=0;i<numComb;i++){ html+='<tr>'; const temp={}; level.inputs.forEach((inp,index)=>{ temp[inp]=!!((i>>(level.inputs.length-1-index))&1); html+=`<td>${temp[inp]?1:0}</td>`; });
        const tempVal={}; level.gates.forEach(g=>{
            const inVal=g.inputs.map(i=>temp.hasOwnProperty(i)?temp[i]:tempVal[i]||false); let res;
            switch(g.type){ case 'AND': res=inVal.every(v=>v); break; case 'OR': res=inVal.some(v=>v); break; case 'NOT': res=!inVal[0]; break; case 'XOR': res=inVal.reduce((a,b)=>a!==b,false); break; case 'XNOR': res=!inVal.reduce((a,b)=>a!==b,false); break; case 'NAND': res=!inVal.every(v=>v); break; case 'NOR': res=!inVal.some(v=>v); break; default: res=false; }
            tempVal[g.output]=res;
        }); level.outputs.forEach(o=>{ const val=tempVal[o]?1:0; html+=`<td>${val}</td>`; }); html+='</tr>'; }
    html+='</table'; contentEl.innerHTML=html; document.getElementById('truthTable').style.display='block';
}

// --- CIRCUIT INFO ---
function showCircuitInfo(){ const level=levels[currentLevel-1]; const msg=document.getElementById('message'); let info=`<h4>${level.title}</h4>`; info+=`<p>Inputs: ${level.inputs.join(', ')}</p>`; info+=`<p>Outputs: ${level.outputs.join(', ')}</p>`; info+=`<ul>`; level.gates.forEach(g=>info+=`<li>${g.type} gate: ${g.inputs.join(' + ')} ‚Üí ${g.output}</li>`); info+='</ul>'; msg.className='success'; msg.innerHTML=info; msg.style.display='block'; }

window.addEventListener('load', initGame);
</script>
</body>
</html>
